{
  "_args": [
    [
      {
        "raw": "cmdutil@^1.0.0",
        "scope": null,
        "escapedName": "cmdutil",
        "name": "cmdutil",
        "rawSpec": "^1.0.0",
        "spec": ">=1.0.0 <2.0.0",
        "type": "range"
      },
      "C:\\Users\\suvo\\Desktop\\Project_drapan\\Project_Darpan\\jubi-solutions\\node_modules\\fast"
    ]
  ],
  "_from": "cmdutil@>=1.0.0 <2.0.0",
  "_id": "cmdutil@1.1.0",
  "_inCache": true,
  "_location": "/cmdutil",
  "_nodeVersion": "0.12.7",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/cmdutil-1.1.0.tgz_1470160163726_0.05558395734988153"
  },
  "_npmUser": {
    "name": "dap",
    "email": "dap@cs.brown.edu"
  },
  "_npmVersion": "2.11.3",
  "_phantomChildren": {},
  "_requested": {
    "raw": "cmdutil@^1.0.0",
    "scope": null,
    "escapedName": "cmdutil",
    "name": "cmdutil",
    "rawSpec": "^1.0.0",
    "spec": ">=1.0.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/fast"
  ],
  "_resolved": "https://registry.npmjs.org/cmdutil/-/cmdutil-1.1.0.tgz",
  "_shasum": "5a4cf3ec9b2b5edb069d2c339fa01f904427fd0c",
  "_shrinkwrap": null,
  "_spec": "cmdutil@^1.0.0",
  "_where": "C:\\Users\\suvo\\Desktop\\Project_drapan\\Project_Darpan\\jubi-solutions\\node_modules\\fast",
  "author": {
    "name": "Joyent",
    "url": "joyent.com"
  },
  "bugs": {
    "url": "https://github.com/joyent/node-cmdutil/issues"
  },
  "dependencies": {
    "assert-plus": "0.1.5",
    "extsprintf": "1.3.0"
  },
  "description": "common command-line program library functions",
  "devDependencies": {
    "verror": "1.6.0"
  },
  "directories": {},
  "dist": {
    "shasum": "5a4cf3ec9b2b5edb069d2c339fa01f904427fd0c",
    "tarball": "https://registry.npmjs.org/cmdutil/-/cmdutil-1.1.0.tgz"
  },
  "gitHead": "e0828478cc3a26e3360a10f3de81e376f2e69aee",
  "homepage": "https://github.com/joyent/node-cmdutil#readme",
  "license": "MIT",
  "main": "./lib/cmdutil.js",
  "maintainers": [
    {
      "name": "dap",
      "email": "dap@cs.brown.edu"
    }
  ],
  "name": "cmdutil",
  "optionalDependencies": {},
  "readme": "# node-cmdutil: common command-line program functions\n\nThis module provides a few functions that are useful for command-line programs\nwritten in Node.\n\n* [warn(...)](#warn): print a warning message to stderr\n* [fail(...)](#fail): print a warning message to stderr and exit\n* [usage(...)](#usage): print a usage message to stderr and exit\n* [exitOnEpipe](#exitOnEpipe): exit normally (with status 0) when EPIPE is seen\n  on stdout.  This causes Node programs to behave like other programs do by\n  default on most Unix-like systems.  See details below.\n* [confirm](#confirm): print a message to stdout, read one byte of input from\n  stdin, and test whether it appears affirmative\n\nYou should also check out:\n\n* [node-getopt](https://github.com/davepacheco/node-getopt) for POSIX option\n  parsing\n* [node-tab](https://github.com/davepacheco/node-tab) for reading and writing\n  tables similar to other Unix tools\n* [node-verror](https://github.com/davepacheco/node-verror) for constructing\n  error chains that produce useful messages for command-line tools\n* [node-extsprintf](https://github.com/davepacheco/node-extsprintf) for Node.js\n  analogs to printf(), fprintf(), and sprintf().\n* [node-cmdln](https://github.com/trentm/node-cmdln) for an alternative\n  framework for building command-line programs\n\n\n# Functions\n\nThe interfaces here follow [Joyent's Best Practices for Error Handling in\nNode.js](https://www.joyent.com/developers/node/design/errors).\n\nAll of the functions here except for `confirm()` are synchronous.  None of the\nfunctions in this module emit operational errors.  The only possible errors are\ninvalid arguments, which are programmer errors.  These are thrown and should not\nbe handled.\n\n\n## warn(...)\n\n`warn(...)` emits a warning message to stderr in the same format as most other\nUnix tools, which is that the warning message is prefixed with the program name.\nSee configure() below.\n\nYou can supply arguments in one of two ways.\n\n    warn(err)\n    warn(fmtstr, arg0, arg1, ...)\n\n* If the first argument is an instance of Error, then the message printed will\n  be `err.message`.\n* Otherwise, all arguments will be passed directly to node-extsprintf's\n  `sprintf` function.  This works similar to Node's `util.format`, but it\n  supports many more format specifiers and it's stricter about null and\n  undefined types.\n\nFor example, this test program called \"warn.js\" produces:\n\n```javascript\nvar cmdutil = require('../lib/cmdutil');\ncmdutil.warn('test message');\n```\n\nproduces:\n\n```\nwarn.js: test message\n```\n\nThis program:\n\n```javascript\ncmdutil.warn('bad argument: \"%s\"', -5);\n```\n\nproduces:\n\n```\nwarn.js: bad argument: \"-5\"\n```\n\nAnd here's an example using an Error:\n\n```javascript\ncmdutil.warn(new Error('bad input'));\n```\n\nwhich produces:\n\n```\nwarn.js: bad input\n```\n\nYou can change the program name that gets printed using `configure()`:\n\n```javascript\ncmdutil.configure({\n    'progname': 'myprog'\n});\ncmdutil.warn('test message');\n```\n\nwhich prints:\n\n```\nmyprog: test message\n```\n\n\n## fail(...)\n\n`fail(...)` emits a warning message just like `warn(...)`, but then exits the\nprocess using `process.exit()`.\n\nThe arguments are exactly like `warn(..)`, but you may specify an _optional_\nnumeric first argument that indicates the exit status to pass to\n`process.exit()`.  If you don't specify one, the exit status `1` is used.\n\n    fail(err)                             /* will exit with status 1 */\n    fail(fmtstr, arg0, arg1, ...)         /* will exit with status 1 */\n    fail(status, err)                     /* will exit with status \"status\" */\n    fail(status, fmtstr, arg0, arg1, ...) /* will exit with status \"status\" */\n\nThe easiest thing is to just pass an Error:\n\n```\ncmdutil.configure({ 'progname': 'myprog' });\ncmdutil.fail(new Error('something went wrong');\n/* This code is never reached. */\n```\n\nwhich outputs:\n\n```\n$ node examples/fail-error.js \nmyprog: something went wrong\n$ echo $?\n1\n```\n\nYou can use [node-verror](https://github.com/davepacheco/node-verror) to chain\ntogether messages:\n\n```javascript\nvar cmdutil = require('../lib/cmdutil');\nvar fs = require('fs');\nvar VError = require('verror');\n\ncmdutil.configure({ 'progname': 'myprog' });\ntry {\n        fs.statSync('/nonexistent_file');\n} catch (ex) {\n        cmdutil.fail(new VError(ex, 'something went wrong'));\n        /* This code is never reached. */\n}\n```\n\nThis outputs:\n\n```\n$ node examples/fail-verror.js \nmyprog: something went wrong: ENOENT, no such file or directory '/nonexistent_file'\n$ echo $?\n1\n```\n\nJust like with `warn()`, you can instead pass printf-style args:\n\n```javascript\nvar cmdutil = require('../lib/cmdutil');\ncmdutil.configure({ 'progname': 'myprog' });\ncmdutil.fail('something %s went wrong', 'very bad');\n/* This code is never reached. */\n```\n\nproduces:\n\n```\n$ node examples/fail-printflike.js \nmyprog: something very bad went wrong\n$ echo $?\n1\n```\n\nAs mentioned above, with either invocation, you can specify a leading number to\nuse as the exit status instead of the default status of `1`:\n\n```javascript\nvar cmdutil = require('../lib/cmdutil');\ncmdutil.configure({ 'progname': 'myprog' });\ncmdutil.fail(7, 'something %s went wrong', 'very bad');\n/* This code is never reached. */\n```\n\nwhich does this:\n\n```\n$ node examples/fail-status.js \nmyprog: something very bad went wrong\n$ echo $?\n7\n```\n\n## usage()\n\nusage() does several things, in order:\n\n* prints an optional warning message\n* prints one or more synopses representing different ways to invoke your program\n* prints a message of additional usage information\n* exits with status `2` (as is standard for usage errors)\n\nThe synopses and additional usage information are whatever was last passed to\n`configure()`.  You must have previously called `configure()` with valid values\nfor these.\n\nIf you invoke usage() with no arguments, then only the usage message is printed.\nIf you pass arguments, they're treated exactly as they are for `warn()`: they\ncan be an Error or a series of printf-like arguments.  These are used to\nconstruct an error message that's printed to stderr before the warning message.\n\nHere's an example:\n\n```javascript\ncmdutil.configure({\n    'progname': 'myprog',\n    'usageMessage': 'Fetch or update the contents of a remote URL.',\n    'synopses': [\n        'fetch  [-v] URL',\n        'upload [-v] URL FILENAME'\n    ]\n});\ncmdutil.usage();\n/* This code is never reached. */\n```\n\nand here's what it prints out:\n\n```\n$ node examples/usage.js \nusage: myprog fetch  [-v] URL\n       myprog upload [-v] URL FILENAME\nFetch or update the contents of a remote URL.\n$ echo $?\n2\n```\n\nYou can also use the usual `warn()`-like arguments to print a warning message:\n\n```javascript\ncmdutil.configure({\n    'progname': 'myprog',\n    'usageMessage': 'Fetch or update the contents of a remote URL.',\n    'synopses': [\n        'fetch  [-v] URL',\n        'upload [-v] URL FILENAME'\n    ]\n});\ncmdutil.usage(new Error('no URL specified'));\n/* This code is never reached. */\n```\n\nwhich prints:\n\n```\n$ node examples/usage-warn.js \nmyprog: no URL specified\nusage: myprog fetch  [-v] URL\n       myprog upload [-v] URL FILENAME\nFetch or update the contents of a remote URL.\n```\n\n\n## configure(args)\n\n`configure(args)` takes arguments as named properties of `args`.  Supported\nproperties are:\n\n* `synopses`: an array of strings that are used in the `usage()` output.  See\n  `usage()` below.\n* `usageMessage`: a string message that is used when you call `usage(...)`.  See\n  `usage()` below.\n* `progname`: a string used as the program name in warning messages.  If\n  unspecified, the program name is taken by applying Node's `path.basename`\n  function on `process.argv[1]`.\n\nThe only time you _need_ to call this function is if you're going to use the\n`usage()` function later, and in that case you must specify `usageMessage` and\n`synopses`.  If you specify either of these, you must also specify the other.\nIf you call this function multiple times, only the last values for any of the\nabove properties will be used.\n\n\n## exitOnEpipe()\n\nThis function causes an EPIPE error on `process.stdout` to to exit the program\nimmediately with status 0, using `process.exit(0)`.  This makes a Node program\nbehave like most other programs on Unix-like systems.  Any other errors on\n`stdout` will be thrown with `throw`, so these errors will be uncatchable.  Do\nnot use this function if you intend to handle other errors on stdout.\n\nThis function takes no arguments and produces no errors.\n\n**Background**: By default, on Unix-like systems, programs automatically exit\nwith status 0 when they receive SIGPIPE.  This behavior supports the common\npattern of piping one command into another but having the first program\nterminate if the second program terminates.  For example, if you generate many\nlines of output and pipe it to `head(1)`:\n\n    # yes | head\n    y\n    y\n    y\n    y\n    y\n    y\n    y\n    y\n    y\n    y\n    #\n\nthen this works as you'd expect: the `yes` program exits when this happens,\neven though `yes` normally runs until you explicitly stop it.  We can see\nwhat's going on using `strace` or `truss`:\n\n    # truss -t write yes | head\n    y\n    y\n    y\n    y\n    y\n    y\n    y\n    y\n    y\n    y\n    write(1, \" y\\n y\\n y\\n y\\n y\\n y\\n\".., 5120)    = 5120\n    write(1, \" y\\n y\\n y\\n y\\n y\\n y\\n\".., 5120)    Err#32 EPIPE\n        Received signal #13, SIGPIPE [default]\n\nWe see that the `yes` process got EPIPE from the second `write(2)` system call,\nand that resulted in a `SIGPIPE` being delivered.  The default disposition of\n`SIGPIPE` is to cause the process to exit with status 0.  This is one of those\nbehind-the-scenes mechanisms that makes the Unix shell work the way you'd\nexpect.\n\nBy default, this doesn't happen with Node programs.  Instead, Node crashes on\nthe `EPIPE` from `write(2)`:\n\n    # node -e 'function tick() { console.log(\"y\"); } setInterval(tick, 1000);' | sleep 3\n    \n    events.js:72\n            throw er; // Unhandled 'error' event\n                  ^\n    Error: write EPIPE\n        at errnoException (net.js:907:11)\n        at Object.afterWrite (net.js:723:19)\n    # \n\nWhen this happens, the status code is non-zero, though you have to `set -o\npipefail` in your shell to see that in this example.  This happens because Node\nexplicitly ignores `SIGPIPE` and then emits errors like `EPIPE` on the\nappropriate stream object.  For stdout (and possibly stderr), this is almost\ncertainly not what you want.\n\nCalling `exitOnEpipe()` adds an `'error'` listener to `process.stdout` that\nchecks whether the error is for `EPIPE`.  If so, it calls `process.exit(0)`.\nIf not, it throws the error.  It would be better to propagate it in a way that\ncould be handled, but there's not a great way to do this from this context, and\nit's uncommon that people intend to handle other errors on stdout anyway.\n\n\n## confirm(args, callback)\n\n`confirm(args, callback)` emits a message to stdout, waits for the user to input\na single byte (in raw mode, if it's a TTY), and invokes `callback` with a\nboolean value indicating whether the confirmation was either \"y\" or \"Y\" (for\n\"yes\").  Any other response (including end-of-stream or a blank line) is\nconsidered false.\n\nThe only supported argument inside `args` is:\n\n* `message`: the message to print to stdout (verbatim)\n\n`callback` is invoked as `callback(result)`.  `result` is a boolean indicating\nwhether the user input was affirmative.  There are no operational errors for\nthis function.  Callers are expected to handle errors on stdin if desired.\n\nThis function uses stdin and stdout directly, so callers should take care to\navoid using it in contexts where that's not appropriate (e.g., in a program that\nreads data on stdin or produces formatted data on stdout).  The behavior is\nundefined if stdin has already emitted 'end' when this function is called.\n\n\n# Contributions\n\nContributions welcome.  Code should be \"make prepush\" clean.  To run \"make\nprepush\", you'll need these tools:\n\n* https://github.com/davepacheco/jsstyle\n* https://github.com/davepacheco/javascriptlint\n\nIf you're changing something non-trivial or user-facing, you may want to submit\nan issue first.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/joyent/node-cmdutil.git"
  },
  "scripts": {
    "test": "make test"
  },
  "version": "1.1.0"
}
